---
title: Estimating hiking velocity with rHike
author: K.B. Vernon
date: '2020-04-13'
slug: estimating-hiking-velocity-with-rhike
categories: []
tags:
  - r
  - sf
  - gdistance
  - rHike
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE, 
                      fig.align = 'center')

library(deseRt)
library(rHike)
library(tidyverse)

ggplot2::theme_set(theme_desert())

```

updated: `r format(Sys.time(), '%B %d, %Y')` (_replaced Laplace with Lorentz distribution at Campbell's suggestion_)  

I wanted to learn how to write an R package and I had this recurrent use-case (estimating cost-distance on a grid), so I made [`rHike`](https://github.com/kbvernon/rHike). It's a super-lightweight package that builds on Jacob van Etten's [`gdistance`](https://agrobioinfoservices.github.io/gdistance/) by implementing both Tobler's (1993) and Campbell's (2019) hiking functions, though others could be added. Mainly, it just simplifies the user interface. Development mostly followed the workflow suggested by Hadley Wickham and Jenny Bryan in their [R Packages](https://r-pkgs.org/) book. Mostly...  

<br>

_Where are we going?_ Intuitively, walking speed should vary as a function of slope. Campbell's Hiking Function reflects this using an empirically derived version of the Lorentz distribution:

$$ f(x) = \frac{c}{\pi\, b\left(1+\left[\frac{x-a}{b}\right]^{2}\right)} + d + e\, x $$

where $x$ is the slope at a location measured in degrees. The idea here is first to get an estimate of slope, then use a hiking function like Campbell's to calculate velocity, and finally to use velocity to estimate travel time (among other cost-distances).   

```{r}

slope <- seq(-50, 50, by = 1)

velocity <- hf_campbell(slope, decile = 10)

```

```{r, echo = FALSE, fig.width = 4, fig.height = 3}

ggplot(data = data.frame(x = slope, y = velocity), aes(x = x, y = y)) + 
  geom_line() +
  labs(x = "Slope", y = "Velocity")

```

<br><br>

***

#### R Preamble

```{r}

library(data.table)
library(gdistance)
library(raster)
library(rHike)
library(sf)
library(tidyverse)
library(viridis)

```

<br>

Coordinate Reference System (CRS):  

```{r}

utm12 <- st_crs(26912)

```

<br>

It should really be emphasized that 

> the unit of projection should match the unit of the stored values.

In this case, elevation is in meters, so the projection should be in meters too.  

<br><br>

#### Data Wrangling

First, we read in a DEM of the foothills in Salt Lake City, Utah:

```{r}

dem <- raster(system.file("extdata/slc.tif", package = "rHike"))

dem <- projectRaster(dem, crs = utm12$proj4string)

```

<br>

Next we generate an arbitrary point pattern.  

```{r}

start_points <- st_sf(id = 1:3,
                      typ = "start",
                      geometry = st_sfc(st_point(c(424350, 4514200)),
                                        st_point(c(426000, 4515000)),
                                        st_point(c(429000, 4516500)),
                                        crs = utm12))

end_points <- st_sf(id = 1:2,
                    typ = "end",
                    geometry = st_sfc(st_point(c(426200, 4516400)),
                                      st_point(c(427600, 4515600)),
                                      crs = utm12))

```

<br>

```{r, echo = FALSE}

pts <- rbind(start_points, end_points)

tidy_raster(dem, n_pixels = 5000) %>% 
  ggplot() +
  geom_tile(aes(x = x, y = y, fill = value)) + 
  scale_fill_viridis(name = "Elevation (m)", option = "viridis", na.value = "transparent") +
  geom_sf(inherit.aes = FALSE, data = pts, aes(color = typ), shape = 19, size = 3) +
  scale_discrete_manual("color", values = c("start" = "red", "end" = "black"), guide = NULL) +
  coord_sf(datum = utm12) +
  labs(x = "Easting (m)", y = "Northing (m)")

```

<br>

Now we use the elevation data to generate a slope raster and calculate a velocity surface for the average hiker using Campbell's Hiking Function.  

```{r}

slope <- hf_slope(dem)

velocity <- hf_velocity(slope, hf = "campbell", decile = 10)

```

<br>

```{r, echo = FALSE}

tidy_raster(velocity, n_pixels = 5000) %>% 
  ggplot() +
  geom_tile(aes(x = x, y = y, fill = value)) + 
  scale_fill_viridis(name = "Velocity (m/s)", option = "viridis", na.value = "transparent") +
  coord_sf(datum = utm12) +
  labs(x = "Easting (m)", y = "Northing (m)")

```

<br>

#### Calculating Accumulated Cost

Accumulated cost-distance is the total time it takes to travel from one location to another; in this case, to _all_ other locations in the landscape of interest.  

```{r}

cost <- hf_accCost(velocity, 
                   fun = function(x) 1/mean(x), 
                   points = start_points)

# convert seconds to minutes
cost <- cost/60

```

<br>

```{r, echo = FALSE}

tidy_raster(cost, n_pixels = 5000) %>% 
  ggplot() +
  geom_tile(aes(x = x, y = y, fill = value)) + 
  scale_fill_viridis(name = "Time (min)", option = "viridis", na.value = "transparent") +
  geom_sf(inherit.aes = FALSE, data = start_points, shape = 19, color = "red", size = 3) +
  coord_sf(datum = utm12) +
  labs(x = "Easting (m)", y = "Northing (m)")

```

<br>

That looks about right, twenty'ish minutes for the average hiker to walk a half-mile or so around the SLC foothills.  

<br>

#### Calculating Least-Cost Path

```{r}

short_paths <- hf_shortPath(velocity, start_points, end_points)

```

<br>

```{r, echo = FALSE}

tidy_raster(dem, n_pixels = 5000) %>% 
  ggplot() +
  geom_tile(aes(x = x, y = y, fill = value)) + 
  scale_fill_viridis(name = "Elevation (m)", option = "viridis", na.value = "transparent") +
  geom_sf(inherit.aes = FALSE, data = short_paths, linetype = "dashed") +
  geom_sf(inherit.aes = FALSE, data = pts, aes(color = typ), shape = 19, size = 3) +
  scale_discrete_manual("color", values = c("start" = "red", "end" = "black"), guide = NULL) +
  coord_sf(datum = utm12) +
  labs(x = "Easting (m)", y = "Northing (m)")

```


<br><br>

#### Future Work

In this post, conversion between different units was done on the fly. It would be nice to introduce methods to do that in a more rigorous way, so I might look into integrating the [`units`](https://r-quantities.github.io/units/) package at some point.  

<br><br>

#### References

Tobler, Waldo R. (1993). "Three Presentations on Geographical Analysis and Modeling: Non-Isotropic Geographic Modeling, Speculations
on the Geometry of Geography, and Global Spatial Analysis." \emph{National Center for Geographic Information and Analysis, Technical
Report} 93-1.

Campbell, Michael J., Philip E. Dennison, Bret W. Butler, and Wesley G. Page (2019). "Using crowdsourced fitness tracker data
to model the relationship between slope and travel rates. \emph{Applied Geography} 106, 93-107.